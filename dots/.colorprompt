#!/usr/bin/env bash

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt_available=yes;;
esac

if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
  # We have color support; assume it's compliant with Ecma-48
  # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
  # a case would tend to support setf rather than setaf.)
  color_prompt_available=yes
else
  color_prompt_available=
fi

curpath() {
  current_path=${PWD/#$HOME/'~'}
  if [ "$current_path" = "~" ]; then
    echo -e $current_path
  else
    path_parent=${current_path%\/*}
    path_parent_short=`echo $path_parent | sed -r "s|/([^/]{,${path_segment_length}})[^/]*|/\1|g"`
    directory=${current_path##*\/}
    echo -e "$path_parent_short/"
  fi
}

curdir() {
  current_path=${PWD/#$HOME/'~'}
  if [ "$current_path" != "~" ]; then
    echo -e "${current_path##*\/}"
  fi
}

colorize() {
  if [ "$color_prompt_available" = yes ]; then
    local text=$1
    local color=$2

    echo -e "${color}${1}${c_clear}"
  else
    echo -e "$1"
  fi
}

git_transform_semaphore() {
  local text="$1"

  local cached=""
  if [[ $text == *"+"* ]]; then
    cached=`colorize "•" $c_git_cached`
  fi

  local dirty=""
  if [[ $text == *"*"* ]]; then
    dirty=`colorize "•" $c_git_dirty`
  fi

  local untracked=""
  if [[ $text == *"%"* ]]; then
    untracked=`colorize "•" $c_git_untracked`
  fi

  echo -e "${cached}${dirty}${untracked}"
}

git_transform_ps1() {
  GIT_PS1_SHOWDIRTYSTATE=1
  GIT_PS1_SHOWUNTRACKEDFILES=1
  GIT_PS1_SHOWCOLORHINTS=1

  local ps1="$(__git_ps1 "%s")"
  if [ -z "$ps1" ]; then
    echo -e ""
		return
	fi

  IFS=" " read -ra ps1array <<< "$ps1"

  local branch="${ps1array[0]}"
  local semaphore_array="${ps1array[@]:1}"
  local semaphore="${semaphore_array[*]}"

  local open_bracket=`colorize "[" $c_git_base`
  local branch_name=`colorize $branch $c_git_base`
  local status=`git_transform_semaphore "$semaphore"`
  local close_bracket=`colorize "]" $c_git_base`

  echo -e "${open_bracket}${branch_name}${status}${close_bracket} "
}

custom_ps1() {
  local base_path=`colorize "$(curpath)" $c_path_base`
  local directory=`colorize "$(curdir) " $c_path_curdir`

  echo -e "${base_path}${directory}$(git_transform_ps1)"
}

path_segment_length=1
c_path_base='\033[0;34m' # blue
c_path_curdir='\033[1;36m' # cyan bold
c_git_base='\033[1;32m' # green bold
c_git_cached='\033[1;32m' # green bold
c_git_dirty='\033[1;33m' # yellow bold
c_git_untracked='\033[1;31m' # red bold
c_clear='\033[0m'

PS1='$(eval "custom_ps1")'
